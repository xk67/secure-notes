# Core Features
This page explains the core features of the application in terms of functionality,
security, and data protection.

**Note**: Security concerns are not listed for every feature individually, because
Django’s built-in authentication is enforced throughout the project, and CSRF
protection is applied to all POST requests.

## Django Security

### Authentication

Authentication is handled via Django’s session-based authentication. Sessions are enabled by adding:

- `django.contrib.sessions` to `INSTALLED_APPS`
- `django.contrib.sessions.middleware.SessionMiddleware` to `MIDDLEWARE`

After a successful login, Django creates a server-side session and sets a
`sessionid` cookie in the browser. By default, Django marks the `sessionid`
cookie as `HttpOnly`, which prevents JavaScript from reading it.

Session data is stored in the `django_session` table with the following columns:

- `session_key`: A random 32-character string identifier, generated by
  [`_get_new_session_key`](https://github.com/django/django/blob/stable/5.2.x/django/contrib/sessions/backends/base.py#L192).  
  This value is stored in the browser as the `sessionid` cookie.
- `session_data`: Serialized session contents that are cryptographically
  signed using the project’s `SECRET_KEY`, performed by
  [`SessionBase.encode()`](https://github.com/django/django/blob/stable/5.2.x/django/contrib/sessions/backends/base.py#L122).
- `expire_date`: timestamp after which the session is considered invalid.

Authorization for protected views is enforced at the view level using the
`@login_required` decorator, ensuring that only authenticated users can access
those endpoints.

For more information, see the Django sessions documentation
[here](https://docs.djangoproject.com/en/5.2/topics/http/sessions/).

### CSRF Protection

CSRF protection is handled via Django and can be activated by adding:

- `django.middleware.csrf.CsrfViewMiddleware` to `MIDDLEWARE`.

On every POST request, a hidden token named `csrfmiddlewaretoken` is sent
to verify the request.

A detailed description is available in the Django documentation:

- How it works: https://docs.djangoproject.com/en/5.2/ref/csrf/#how-it-works
- How to use it: https://docs.djangoproject.com/en/6.0/howto/csrf/

### Authorization

Authorization in Django is enabled by adding
`django.contrib.auth.middleware.AuthenticationMiddleware` to the `MIDDLEWARE`
list.

This middleware allows each view to access `request.user`, which represents
the authenticated user making the request. Using `request.user`, the
application can enforce access control, for example:

- Checking ownership of resources: `note.owner == request.user`
- Filtering querysets to include only authorized objects: `Note.objects.filter(owner=request.user)`

### Templating

Django’s template system automatically escapes variables by default, which
provides built-in protection against Cross-Site Scripting (XSS) attacks.

When rendering user-provided data in templates, special characters are
converted to safe HTML entities, preventing malicious scripts from executing.

For more details, see the Django documentation on XSS protection:  
[Cross-Site Scripting (XSS) Protection](https://docs.djangoproject.com/en/5.2/topics/security/#cross-site-scripting-xss-protection)

### SQL Injection Protection

Django’s ORM (Object-Relational Mapper) protects against SQL injection by
using parameterized queries for all database operations.

User-supplied input is never directly concatenated into SQL statements.
Instead, the ORM safely escapes parameters and constructs queries, ensuring
that malicious input cannot alter the intended SQL logic.

For more details, see the Django documentation on SQL injection protection:  
[SQL Injection Protection](https://docs.djangoproject.com/en/5.2/topics/security/#sql-injection-protection)

### Additional Security Measures

Django provides many other built-in security protections see:
[Django Security Guide](https://docs.djangoproject.com/en/5.2/topics/security/)

## User Login

### Technical Implementation

User login is completely handled by Django’s
[LoginView](https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/views.py#L66) view.

An HTTP **POST** request is sent to `/login` with the following
`application/x-www-form-urlencoded` fields:

- `csrfmiddlewaretoken`
- `username`
- `password`

The built-in [AuthenticationForm](https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/forms.py#L335) uses the same error message for wrong usernames and passwords.

### Potential Vulnerabilities and Mitigations

**Username Enumeration**  

An attacker could try to discover which usernames exist based on login error messages.

Mitigation: Use the same login error message for both non-existent usernames and incorrect passwords.

**SQL Injection**  

The `username` and `password` are used to query the database, which could raise concerns about SQL injection.

Mitigation: Use Django’s ORM and query parameterization to ensure that SQL code and user-supplied parameters are handled separately and safely escaped.
 
### Data Protection

After a successful login, session get stored and last login*.

## User Logout

### Technical Implementation

User logout is handled by Django’s built-in
[LogoutView](https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/views.py#L125) view.

An HTTP **POST** request is sent to `/logout` with the following
`application/x-www-form-urlencoded` field:

- `csrfmiddlewaretoken`

After logout, the user session is invalidated and the `sessionid` cookie
is removed.

### Data Protection

During the logout process, no personal data is stored*.

## User Registration

### Technical Implementation

The registration is handled via a custom signup view that uses a custom form based on [UserCreationForm](https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/forms.py#L271).

HTTP **POST** request to `/signup` with the following application/x-www-form-urlencoded data:

  - `csrfmiddlewaretoken`
  - `username`
  - `email`
  - `password1`
  - `password2`

Data validation is handled by Django’s built-in validators:

**Username**:

  - [UnicodeUsernameValidator](https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/validators.py#L19) is used, enforcing a strict whitelist of allowed characters (letters, numbers, and @ . + - _ )
  - Must be unique among other users and has a maximum length of 150 characters ([User model](https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/models.py#L456))
  
**Email**: [EmailValidator](https://github.com/django/django/blob/stable/5.2.x/django/core/validators.py#L210) ensures a correctly formatted email address

**Password**:
  
  - [validate_password](https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/forms.py#L107) ensures `password1` matches `password2`
  - [validate_password](https://github.com/django/django/blob/main/django/contrib/auth/password_validation.py#L41) validates the password using the validators set in `AUTH_PASSWORD_VALIDATORS`:
    
    - `UserAttributeSimilarityValidator` checks similarity between the password and a set of user attributes
    - `MinimumLengthValidator` checks whether the password meets a minimum length of 15.
    - `CommonPasswordValidator` checks whether the password occurs in a list of common passwords (default list includes 20,000 passwords from [roycewilliams](https://gist.github.com/roycewilliams/226886fd01572964e1431ac8afc999ce))
    - `NumericPasswordValidator` checks whether the password is not entirely numeric
    - The implementation of the validators can be found [here](https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/password_validation.py)

  - **Password hashing**: Django uses [PBKDF2](https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/hashers.py#L311) with SHA256 by default. Each password is hashed with:
  
    - **Algorithm**: `pbkdf2_sha256`
    - **Iterations**: 1,000,000
    - **Salt**: randomly generated string via [get_random_string()](https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/hashers.py#L236) and unique per user
    
  - The password is stored as `<algorithm>$<iterations>$<salt>$<hash>` in the database
  - For more information on how Django handles passwords, see [Password Management in Django](https://docs.djangoproject.com/en/6.0/topics/auth/passwords/#password-management-in-django)

After registration, a verification email is sent to the provided email address.
The email contains a unique verification link. Only after the user clicks this
link is the account activated (`is_active = true`) and login becomes possible.
This ensures that the email address is owned by the registering user.

### Potential Vulnerabilities and Mitigations

**Username or Email Enumeration**

An attacker could try to discover which usernames or email addresses are registered by observing error messages during registration.

Mitigation: Implemented a uniform error message: `"A user with the given email address or username already exists"` for both username and email conflicts, preventing enumeration.

**Brute Force Attacks**

Attackers could attempt to guess user passwords by trying many combinations.

Mitigation: Users are required to set strong passwords during registration.

**Data Breach**

Passwords stored in plaintext or using weak hashing could be exposed if the database is compromised.

Mitigation: Django stores passwords securely using PBKDF2 with SHA256, unique per-user salt, and 1,000,000 iterations.

**SQL Injection**

The query string is used to filter note titles in the database, which could
raise concerns about SQL injection.

Mitigation: Use Django’s ORM and query parameterization to ensure that
SQL code and user-supplied parameters are handled separately and safely
escaped.

### Data Protection

During user registration, the following data is stored*:

- Username  
- Email address  
- Password (hashed)  
- Date joined  

## Account Deletion

### Technical Implementation

Account deletion is handled via a custom
[delete](https://github.com/xk67/secure-notes/blob/main/src/users/views.py#L89) view.

An HTTP **POST** request is sent to `/delete` with the following
`application/x-www-form-urlencoded` fields:

- `csrfmiddlewaretoken`
- `confirm`
- `password`

The account is deleted only if `confirm` is provided and the submitted
`password` is verified against the currently authenticated user.

### Potential Vulnerabilities and Mitigations

**Unauthorized Account Deletion**

If authentication or ownership checks were missing, an attacker could try
to delete another user’s account.

Mitigation: The view operates on the currently authenticated user only and
verifies the user’s password before performing deletion.

### Data Protection

After account deletion, all personal data associated with the account,
including notes, is permanently deleted*.

## User Profile

### Technical Implementation

The user profile is rendered via a custom [profile](https://github.com/xk67/secure-notes/blob/main/src/users/views.py#L84) view.

An HTTP **GET** request is sent to `/profile`.

The profile page displays the following user-related data:

- `username`
- `email`
- link to password reset
- link to account deletion

### Potential Vulnerabilities and Mitigations

**Cross-Site Scripting (XSS)**

The `username` and `email` address are rendered in the template and originate
from user-controlled input.

Mitigation: Django’s template system automatically escapes all variables
by default, ensuring that special characters are rendered safely and
preventing XSS attacks.

### Data Protection

During the profile view process, no data is stored*.

## Note Search

The note search functionality is implemented via a custom `search_note` view that uses a custom form based on [Form](https://github.com/django/django/blob/stable/5.2.x/django/forms/forms.py#L432) class.

- An HTTP GET request is sent to `/search` with the query string parameter `q` as the search term
- The query string is used to search for notes whose title contains the provided search term
- The response consists of links to:
    - notes owned by the currently authenticated user and
    - public notes belonging to other users
- The query string is rendered on the result page as: `Results for: <q>`
- If no query string is provided or if the query length exceeds 32 characters an error message is shown to the user

### Potential Vulnerabilities and Mitigations

**Broken Access Control**

If access control checks are missing or incorrect, users could see
notes they do not own, including private notes of other users.

Mitigation: Use the ORM `filter()` function to ensure that only notes belonging to the authenticated user are returned.

**Cross-Site Scripting (XSS)**

The search query is reflected on the result page, which could theoretically
be abused if malicious input is provided.

Mitigation: Django’s template system automatically escapes user-supplied
data by default, ensuring special characters are rendered safely.

**SQL Injection**

The query string is used to filter note titles in the database, which could
raise concerns about SQL injection.

Mitigation: Use Django’s ORM and query parameterization to ensure that
SQL code and user-supplied parameters are handled separately and safely
escaped.

### Data Protection

During the note search process no search queries or results are stored*.

## Reset Password

### Technical Implementation

Password reset is fully handled by Django’s built-in authentication views:

- `PasswordResetView`
- `PasswordResetDoneView`
- `PasswordResetConfirmView`
- `PasswordResetCompleteView`

Source code of the views:  
https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/views.py

First, an HTTP **POST** request is sent to `/password_reset` with the following  
`application/x-www-form-urlencoded` fields:

- `csrfmiddlewaretoken`
- `email`

An email is sent to the provided email address containing a password reset link
in the following form: `/reset/<uidb64>/<token>`.

After the user clicks the link, they are redirected to  
`/reset/<uidb64>/set-password`, where a new password can be entered and confirmed.

Submitting the form sends an HTTP **POST** request to  
`/reset/<uidb64>/set-password` with the following  
`application/x-www-form-urlencoded` fields:

- `csrfmiddlewaretoken`
- `new_password1`
- `new_password2`

The same password validators used during account creation are applied to ensure
the new password is sufficiently strong. If valid, the new password is securely
stored using Django’s password hashing mechanism explained at account creation section.

The password reset token is single-use and becomes invalid immediately after
the password is successfully changed. By default, the reset link is valid for
3 days, configurable via `PASSWORD_RESET_TIMEOUT`.

### Potential Vulnerabilities and Mitigations

**User Enumeration**

An attacker could attempt to determine whether an email address exists by
observing password reset responses.

Mitigation: Django always returns the same response regardless of whether the
email exists, preventing user enumeration.

**Token Abuse**

If reset tokens were predictable or reusable, attackers could reset passwords
without authorization.

Mitigation: Django uses time-limited and single-use tokens
that are invalidated after successful password reset.

**User ID Disclosure (`uidb64`)**

The password reset URL contains a Base64-encoded user ID, which could theoretically
be used to infer the number of registered users.

Mitigation: The `uidb64` value alone is insufficient to reset a password. A valid,
time-limited token is also required, making enumeration impractical and non-exploitable.  
To further prevent user ID leakage, the system could combine the user ID with a
random value or use a fully random identifier in the reset URL instead of exposing
`uidb64`. This ensures attackers cannot infer valid user IDs from the URL.

**SQL Injection**

User-controlled input (`email` and password fields) is processed during the reset
workflow.

Mitigation: Django’s ORM uses parameterized queries, ensuring SQL code and
user-supplied values are handled separately and safely escaped by default.

### Data Protection

During the password reset process, only the new password hash is stored*.

## Note Creation

### Technical Implementation
Note creation is handled via a custom
[create_note](https://github.com/xk67/secure-notes/blob/main/src/notes/views/web.py#L15)
view that uses a custom form based on  [ModelForm](https://docs.djangoproject.com/en/stable/topics/forms/modelforms/).

An HTTP **POST** request is sent to `/notes/create` with the following
`application/x-www-form-urlencoded` fields:

  - `csrfmiddlewaretoken`
  - `title`
  - `content`
  - `private`

[Note](https://github.com/xk67/secure-notes/blob/main/src/notes/models.py#L5)
model stores all note-related data. Django models define database schemas
using Python objects and are managed via Django’s ORM, for more information see [here](https://www.geeksforgeeks.org/python/django-orm-inserting-updating-deleting-data/).

The following columns are defined:

- `owner`: ForeignKey to `AUTH_USER_MODEL` with `on_delete=CASCADE`
- `title`: `CharField` with a maximum length of 32
- `content`: `TextField`
- `private`: `BooleanField` with a default value of `True`
- `uuid`: `UUIDField` with a unique identifier and a default value generated by the model

Before the `title` is inserted into the database, it is sanitized using
[`sanitize_title`](https://github.com/xk67/secure-notes/blob/main/src/notes/utils.py#L155).
Only plain text is allowed

The `content` is submitted by the user in Markdown format and processed
before being stored in the database as follows:

- [markdown2html_safe](https://github.com/xk67/secure-notes/blob/main/src/notes/utils.py#L147) is called, which:
- converts Markdown to HTML
- sanitizes the resulting HTML using predefined
    [ALLOWED_TAGS](https://github.com/xk67/secure-notes/blob/main/src/notes/utils.py#L11),
    [ALLOWED_ATTRIBUTES](https://github.com/xk67/secure-notes/blob/main/src/notes/utils.py#L33),
    and
    [ALLOWED_PROTOCOLS](https://github.com/xk67/secure-notes/blob/main/src/notes/utils.py#L9)

If the title or content is not submitted, the user receives an error
message generated by the custom
[NoteForm](https://github.com/xk67/secure-notes/blob/main/src/notes/forms.py#L5).

On success, the user is provided with a link to the newly created note in the form: `/notes/<uuid>`

### Potential Vulnerabilities and Mitigations

**SQL Injection**

User-controlled input (`title` and `content`) is written to the database during
note creation.

Django’s ORM mitigates SQL injection risks by using parameterized queries.
SQL statements and user-supplied values are handled separately, and all
parameters are safely escaped by default.

### Data Protection

During the note creation, the following personal data is stored:

- note owner
- note title
- note content
- note UUID

Users have the right to delete their notes at any time*.

## List Notes

### Technical Implementation
List notes is handled via a custom
[list_notes](https://github.com/xk67/secure-notes/blob/main/src/notes/views/web.py#L34)
view.

An simple HTTP **GET** request is sent to `/notes` and returns notes owned by the current user or other public notes.

### Potential Vulnerabilities and Mitigations

**Broken Access Control**

If access control checks are missing or incorrect, users could see
notes they do not own, including private notes of other users.

Mitigation: Use the ORM `filter()` function to return only public notes
and `user.notes.all()` to include all notes owned by the authenticated user.

**Cross-Site Scripting (XSS)**

The note title is reflected on the page, which could theoretically
be abused if malicious note title was set.

Mitigation: Use Django’s template system to automatically escape variables,
ensuring special characters are rendered safely. Note titles are also
sanitized at creation.

### Data Protection

During the list note process nothing is stored*.

## View Notes

### Technical Implementation

View note is handled via a custom
[view_note](https://github.com/xk67/secure-notes/blob/main/src/notes/views/web.py#L49).

An HTTP **GET** request is sent to `/notes/<uuid>` and returns the note
identified by its UUID. Notes are rendered as HTML.

To render the stored HTML content without Django escaping it, the view uses
`mark_safe(note.content)`.

There is also a **POST** endpoint to delete a note owned by the currently
authenticated user. The request uses `application/x-www-form-urlencoded`
fields:

- `csrfmiddlewaretoken`
- `confirm`

### Potential Vulnerabilities and Mitigations

**Broken Access Control (Deletion)**

If access control checks are missing or incorrect, users could delete notes
they do not own.

Mitigation: Ensure the note is owned by the current user before allowing
deletion (e.g., `if note.owner != request.user: ...`).

**Cross-Site Scripting (XSS)**

The note `title`, `content`, and `username` are rendered in the UI.

Mitigation: Rely on server-side sanitization during note creation (title and content). Keep Django’s
auto-escaping enabled for all other fields and only use `mark_safe` on
content that has been sanitized.

**SQL Injection**

User-controlled input (`uuid`) is used to look up a note in the database.

Mitigation: Django’s ORM uses parameterized queries, separating SQL from
user-supplied values and safely escaping parameters.

### Data Protection

During the view note process nothing is stored*.

## Preview Note

### Technical Implementation

Previewing a note is handled via a custom
[preview_note](https://github.com/xk67/secure-notes/blob/main/src/notes/views/web.py#L106) view.

An HTTP AJAX **POST** request is sent to `/note/preview` with the following
`application/x-www-form-urlencoded` fields:

- `csrfmiddlewaretoken`
- `content`

The internal `markdown2html_safe` function is called to convert and sanitize
the content.

For the AJAX request and rendering, [md-editor](https://github.com/xk67/secure-notes/blob/main/src/static/js/md-editor.js) is used.

### Potential Vulnerabilities and Mitigations

**Cross-Site Scripting (XSS)**

User-provided content is rendered in the UI.

Mitigation: Rely on server-side sanitization via `markdown2html_safe` during
note preview.

## Social Plugin

### Technical Implementation

The Social Plugin is implemented as a Markdown extension: [Yt2iframe](https://github.com/xk67/secure-notes/blob/main/src/notes/utils.py#L139).

A regex, [EMBED_RE](https://github.com/xk67/secure-notes/blob/main/src/notes/utils.py#L40), is registered and looks for the following pattern during Markdown conversion: `![<optional title>](embed:<YouTube link>)`

The following YouTube link formats are allowed:

- `https://youtu.be/<video_id>`
- `https://www.youtu.be/<video_id>`
- `https://youtube.com/watch?v=<video_id>`
- `https://www.youtube.com/watch?v=<video_id>`

`http` is also accepted.

If a valid link is provided, it is converted to `https://www.youtube-nocookie.com/embed/<video_id>`.

Then an `<iframe>` is generated (see attributes [here](https://github.com/xk67/secure-notes/blob/main/src/notes/utils.py#L93)) and wrapped in a template that renders a consent banner.

Accepting the consent banner and loading the iframe is handled by the [embed-consent](https://github.com/xk67/secure-notes/blob/main/src/static/js/embed-consent.js) script.

The consent banner is created on the backend to keep the frontend implementation simple. As a result, API consumers who render note content themselves must implement a compatible consent mechanism client-side.

### Potential Vulnerabilities and Mitigations

**Clickjacking**

If an attacker can cause an iframe to load an arbitrary origin the embedded page may be used for phishing.

Mitigation: The plugin only accepts specific YouTube URL patterns and rewrites them to the fixed host `www.youtube-nocookie.com` with a strict `/embed/<video_id>` path. Any non-matching URLs are rejected and are not converted into iframes.

**Permission Scope**

If the iframe is granted broad capabilities it can increase the attack surface and privacy impact.

Mitigation: Keep iframe attributes restrictive. Limit capabilities via the `allow` attribute.

### Data Protection

No data is stored during iframe generation itself. To avoid automatically loading YouTube content (and thereby preventing immediate data transfer to YouTube/Google), a consent banner is implemented. The video is only loaded if a user explicitly accepts it*.

\* For more information on data processing and user rights, refer to the Secure Notes data protection page.
