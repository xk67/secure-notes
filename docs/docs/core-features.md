# Core Features

## Django Security

### Authentication

Authentication is handled via Django’s session-based authentication. Sessions are enabled by adding:

- `django.contrib.sessions` to `INSTALLED_APPS`
- `django.contrib.sessions.middleware.SessionMiddleware` to `MIDDLEWARE`

After a successful login, Django creates a server-side session and sets a
`sessionid` cookie in the browser. By default, Django marks the `sessionid`
cookie as `HttpOnly`, which prevents JavaScript from reading it.

Session data is stored in the `django_session` table with the following columns:

- `session_key`: A random 32-character string identifier, generated by
  [`_get_new_session_key`](https://github.com/django/django/blob/stable/5.2.x/django/contrib/sessions/backends/base.py#L192).  
  This value is stored in the browser as the `sessionid` cookie.
- `session_data`: Serialized session contents that are cryptographically
  signed using the project’s `SECRET_KEY`, performed by
  [`SessionBase.encode()`](https://github.com/django/django/blob/stable/5.2.x/django/contrib/sessions/backends/base.py#L122).
- `expire_date`: timestamp after which the session is considered invalid.

Authorization for protected views is enforced at the view level using the
`@login_required` decorator, ensuring that only authenticated users can access
those endpoints.

For more information, see the Django sessions documentation
[here](https://docs.djangoproject.com/en/5.2/topics/http/sessions/).

### CSRF Protection

CSRF protection is handled via Django and can be activated by adding:

- `django.middleware.csrf.CsrfViewMiddleware` to `MIDDLEWARE`.

On every POST request, a hidden token named `csrfmiddlewaretoken` is sent
to verify the request.

A detailed description is available in the Django documentation:

- How it works: https://docs.djangoproject.com/en/5.2/ref/csrf/#how-it-works
- How to use it: https://docs.djangoproject.com/en/6.0/howto/csrf/

## User Registration

### Technical Implementation

The registration is handled via a custom signup view that uses a custom form based on [UserCreationForm](https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/forms.py#L271).

HTTP POST request to `/signup` with the following application/x-www-form-urlencoded data:

  - `csrfmiddlewaretoken`
  - `username`
  - `email`
  - `password1`
  - `password2`

Data validation is handled by Django’s built-in validators:

**Username**:

  - [UnicodeUsernameValidator](https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/validators.py#L19) is used, enforcing a strict whitelist of allowed characters (letters, numbers, and @ . + - _ )
  - Must be unique among other users and has a maximum length of 150 characters ([User model](https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/models.py#L456))
  
**Email**: [EmailValidator](https://github.com/django/django/blob/stable/5.2.x/django/core/validators.py#L210) ensures a correctly formatted email address

**Password**:
  
  - [validate_password](https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/forms.py#L107) ensures `password1` matches `password2`
  - [validate_password](https://github.com/django/django/blob/main/django/contrib/auth/password_validation.py#L41) validates the password using the validators set in `AUTH_PASSWORD_VALIDATORS`:
    
    - `UserAttributeSimilarityValidator` checks similarity between the password and a set of user attributes
    - `MinimumLengthValidator` checks whether the password meets a minimum length
    - `CommonPasswordValidator` checks whether the password occurs in a list of common passwords (default list includes 20,000 passwords from [roycewilliams](https://gist.github.com/roycewilliams/226886fd01572964e1431ac8afc999ce))
    - `NumericPasswordValidator` checks whether the password is not entirely numeric
    - The implementation of the validators can be found [here](https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/password_validation.py)

  - **Password hashing**: Django uses [PBKDF2](https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/hashers.py#L311) with SHA256 by default. Each password is hashed with:
  
    - **Algorithm**: `pbkdf2_sha256`
    - **Iterations**: 1,000,000
    - **Salt**: randomly generated string via [get_random_string()](https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/hashers.py#L236) and unique per user
    
  - The password is stored as `<algorithm>$<iterations>$<salt>$<hash>` in the database
  - For more information on how Django handles passwords, see [Password Management in Django](https://docs.djangoproject.com/en/6.0/topics/auth/passwords/#password-management-in-django)

### Potential Vulnerabilities and Mitigations

**Username or Email Enumeration**

  - **Vulnerability**: An attacker could try to discover which usernames or email addresses are registered by observing error messages during registration.
  - **Mitigation**: Implemented a uniform error message: `"A user with the given email address or username already exists"` for both username and email conflicts, preventing enumeration.

**Weak Passwords**

  - **Vulnerability**: Users may choose passwords that are easy to guess or are included in common password lists
  - **Mitigation**: Enforced password validation using Django's validators:
    - Minimum length (default: 8 characters)
    - Not entirely numeric
    - Not included in the common passwords list
    - Not too similar to user attributes

**Cross-Site Request Forgery (CSRF)**

  - **Vulnerability**: Malicious sites could submit forms on behalf of a user
  - **Mitigation**: Django's CSRF middleware automatically protects the signup form

**Password Storage**

  - **Vulnerability**: Passwords stored in plaintext or using weak hashing could be exposed if the database is compromised
  - **Mitigation**: Django stores passwords securely using PBKDF2 with SHA256, unique per-user salt, and 1,000,000 iterations

**Input Sanitization / Injection**

  - **Vulnerability**: Unsanitized form input could lead to XSS or SQL injection.
  - **Mitigation**: Django forms automatically sanitize input and use parameterized queries through the ORM, preventing these attacks.

### Data Protection

During user registration, the following data is stored*:

- Username  
- Email address  
- Password (hashed)  
- Date joined  
- Last login  

## Note Search

The note search functionality is implemented via a custom `search_note` view that uses a custom form based on [Form](https://github.com/django/django/blob/stable/5.2.x/django/forms/forms.py#L432) class.

- An HTTP GET request is sent to `/search` with the query string parameter `q` as the search term
- The query string is used to search for notes whose title contains the provided search term
- The response consists of links to:
    - notes owned by the currently authenticated user and
    - public notes belonging to other users
- The query string is rendered on the result page as: `Results for: <q>`
- If no query string is provided or if the query length exceeds 32 characters an error message is shown to the user

### Potential Vulnerabilities and Mitigations

**Broken Access Control**

If access control checks are missing or incorrect, users could see
notes they do not own, including private notes of other users.

Mitigation: Use the ORM `filter()` function to ensure only public notes
are returned and `user.notes.all()` to include all notes owned by the
authenticated user.

**Cross-Site Scripting (XSS)**

The search query is reflected on the result page, which could theoretically
be abused if malicious input is provided.

Mitigation: Django’s template system automatically escapes user-supplied
data by default, ensuring special characters are rendered safely.

**SQL Injection**

The query string is used to filter note titles in the database, which could
raise concerns about SQL injection.

Mitigation: Use Django’s ORM and query parameterization to ensure that
SQL code and user-supplied parameters are handled separately and safely
escaped.

### Data Protection

During the note search process no search queries or results are stored*.

## Note Creation

### Technical Implementation
Note creation is handled via a custom
[`create_note`](https://github.com/xk67/secure-notes/blob/main/src/notes/views/web.py#L15)
view that uses a custom form based on  [ModelForm](https://docs.djangoproject.com/en/stable/topics/forms/modelforms/).

An HTTP **POST** request is sent to `/notes/create` with the following
`application/x-www-form-urlencoded` fields:

  - `csrfmiddlewaretoken`
  - `title`
  - `content`
  - `private`

[`Note`](https://github.com/xk67/secure-notes/blob/main/src/notes/models.py#L5)
model stores all note-related data. Django models define database schemas
using Python objects and are managed via Django’s ORM, for more information see [here](https://www.geeksforgeeks.org/python/django-orm-inserting-updating-deleting-data/).

The following columns are defined:

- `owner`: ForeignKey to `AUTH_USER_MODEL` with `on_delete=CASCADE`
- `title`: `CharField` with a maximum length of 32
- `content`: `TextField`
- `private`: `BooleanField` with a default value of `True`
- `uuid`: `UUIDField` with a unique identifier and a default value generated by the model

Before the **title** is inserted into the database, it is sanitized using
[`sanitize_title`](https://github.com/xk67/secure-notes/blob/main/src/notes/utils.py#L155).
Only plain text is allowed

The **content** is submitted by the user in Markdown format and processed
before being stored in the database as follows:

- [`markdown2html_safe`](https://github.com/xk67/secure-notes/blob/main/src/notes/utils.py#L147) is called, which:
- converts Markdown to HTML
- sanitizes the resulting HTML using predefined
    [`ALLOWED_TAGS`](https://github.com/xk67/secure-notes/blob/main/src/notes/utils.py#L11),
    [`ALLOWED_ATTRIBUTES`](https://github.com/xk67/secure-notes/blob/main/src/notes/utils.py#L33),
    and
    [`ALLOWED_PROTOCOLS`](https://github.com/xk67/secure-notes/blob/main/src/notes/utils.py#L9)

If the title or content is not submitted, the user receives an error
message generated by the custom
[`NoteForm`](https://github.com/xk67/secure-notes/blob/main/src/notes/forms.py#L5).

On success, the user is provided with a link to the newly created note in the form: `/notes/<uuid>`

### Potential Vulnerabilities and Mitigations

**SQL Injection**

User-controlled input (`title` and `content`) is written to the database during
note creation.

Django’s ORM mitigates SQL injection risks by using parameterized queries.
SQL statements and user-supplied values are handled separately, and all
parameters are safely escaped by default.

### Data Protection

During the note creation, the following personal data is stored:

- note owner
- note title
- note content
- note UUID

Users have the right to delete their notes at any time*.

## List Notes

### Technical Implementation
List notes is handled via a custom
[list_notes](https://github.com/xk67/secure-notes/blob/main/src/notes/views/web.py#L34)
view.

An simple HTTP **GET** request is sent to `/notes` and returns notes owned by the current user or other public notes.

### Potential Vulnerabilities and Mitigations

**Broken Access Control**

If access control checks are missing or incorrect, users could see
notes they do not own, including private notes of other users.

Mitigation: Use the ORM `filter()` function to return only public notes
and `user.notes.all()` to include all notes owned by the authenticated user.

**Cross-Site Scripting (XSS)**

The note title is reflected on the page, which could theoretically
be abused if malicious note title was set.

Mitigation: Use Django’s template system to automatically escape variables,
ensuring special characters are rendered safely. Note titles are also
sanitized at creation.

### Data Protection

During the list note process nothing is stored*.

## View Notes

### Technical Implementation

View note is handled via a custom
[view_note](https://github.com/xk67/secure-notes/blob/main/src/notes/views/web.py#L49).

An HTTP **GET** request is sent to `/notes/<uuid>` and returns the note
identified by its UUID. Notes are rendered as HTML.

To render the stored HTML content without Django escaping it, the view uses
`mark_safe(note.content)`.

There is also a **POST** endpoint to delete a note owned by the currently
authenticated user. The request uses `application/x-www-form-urlencoded`
fields:

- `csrfmiddlewaretoken`
- `confirm`

### Potential Vulnerabilities and Mitigations

**Broken Access Control (Deletion)**

If access control checks are missing or incorrect, users could delete notes
they do not own.

Mitigation: Ensure the note is owned by the current user before allowing
deletion (e.g., `if note.owner != request.user: ...`).

**Cross-Site Scripting (XSS)**

The note title, content, and username are rendered in the UI.

Mitigation: Rely on server-side sanitization during note creation (title and content). Keep Django’s
auto-escaping enabled for all other fields and only use `mark_safe` on
content that has been sanitized.

**SQL Injection**

User-controlled input (`uuid`) is used to look up a note in the database.

Mitigation: Django’s ORM uses parameterized queries, separating SQL from
user-supplied values and safely escaping parameters.

### Data Protection

During the view note process nothing is stored*.

## Social Plugin

### Technical Implementation

The Social Plugin is implemented as a Markdown extension: [Yt2iframe](https://github.com/xk67/secure-notes/blob/main/src/notes/utils.py#L139).

A regex, [EMBED_RE](https://github.com/xk67/secure-notes/blob/main/src/notes/utils.py#L40), is registered and looks for the following pattern during Markdown conversion: `![<optional title>](embed:<YouTube link>)`

The following YouTube link formats are allowed:

- `https://youtu.be/<video_id>`
- `https://www.youtu.be/<video_id>`
- `https://youtube.com/watch?v=<video_id>`
- `https://www.youtube.com/watch?v=<video_id>`

`http` is also accepted.

If a valid link is provided, it is converted to `https://www.youtube-nocookie.com/embed/<video_id>`.

Then an `<iframe>` is generated (see attributes [here](https://github.com/xk67/secure-notes/blob/main/src/notes/utils.py#L93)) and wrapped in a template that renders a consent banner.

Accepting the consent banner and loading the iframe is handled by the [embed-consent](https://github.com/xk67/secure-notes/blob/main/src/static/js/embed-consent.js) script.

The consent banner is created on the backend to keep the frontend implementation simple. As a result, API consumers who render note content themselves must implement a compatible consent mechanism client-side.

### Potential Vulnerabilities and Mitigations

**Clickjacking**

If an attacker can cause an iframe to load an arbitrary origin the embedded page may be used for phishing.

Mitigation: The plugin only accepts specific YouTube URL patterns and rewrites them to the fixed host `www.youtube-nocookie.com` with a strict `/embed/<video_id>` path. Any non-matching URLs are rejected and are not converted into iframes.

**Permission Scope**

If the iframe is granted broad capabilities it can increase the attack surface and privacy impact.

Mitigation: Keep iframe attributes restrictive. Limit capabilities via the `allow` attribute.

### Data Protection

No data is stored during iframe generation itself. To avoid automatically loading YouTube content (and thereby preventing immediate data transfer to YouTube/Google), a consent banner is implemented. The video is only loaded if a user explicitly accepts it*.

\* For more information on data processing and user rights, refer to the Secure Notes data protection page.
